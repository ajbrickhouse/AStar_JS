<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script type="text/javascript" src="convertMaze.js" defer></script>
    <title>Canvas Grid</title>
    <style>
        body,
        html {
            height: 100%;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            border: 2px solid black;
        }
    </style>

</head>

<body>
    <div id="mazeData"></div>
        <div id="canvas">
            <canvas id="gridCanvas" width="623" height="623"></canvas><br>
        </div>
        <div>
            <button id="fetchDataBtn">Fetch Data</button>
        </div>
        <div id="result"></div>
        
    </div> 
    <script>
        window.sharedData = null;

        // Get a reference to the canvas element
        const canvas = document.getElementById("gridCanvas");
        const ctx = canvas.getContext("2d");

        // Constants
        const cols = 29;
        const rows = 29;

        const cellSize = 20; // Size of each cell in pixels
        const canvasWidth = cols * cellSize;
        const canvasHeight = rows * cellSize;

        // Set canvas dimensions
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        const w = canvasWidth / cols;
        const h = canvasHeight / rows;

        // Initialize grid variables
        let grid = new Array(cols);
        // Store the set of nodes to be evaluated
        let openSet = [];
        // Store the set of nodes already evaluated
        let closedSet = [];
        // obstacles
        let obstacles = [];
        // Starting position
        let start;
        // The target position
        let end;
        let path = [];

        // GridPoint class definition
        class GridPoint {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.f = 0;
                this.g = 0;
                this.h = 0;
                this.neighbors = [];
                this.parent = undefined;
                this.walkable = null
            }

            updateNeighbors(grid) {
                const x = this.x,
                    y = this.y;
                if (x < cols - 1) this.neighbors.push(grid[x + 1][y]);
                if (x > 0) this.neighbors.push(grid[x - 1][y]);
                if (y < rows - 1) this.neighbors.push(grid[x][y + 1]); // adjusted for rows
                if (y > 0) this.neighbors.push(grid[x][y - 1]);

                // Adding Diagonal Neighbors (also adjusted for rows)
                if (x > 0 && y > 0) this.neighbors.push(grid[x - 1][y - 1]);
                if (x < cols - 1 && y > 0) this.neighbors.push(grid[x + 1][y - 1]);
                if (x > 0 && y < rows - 1) this.neighbors.push(grid[x - 1][y + 1]); // adjusted for rows
                if (x < cols - 1 && y < rows - 1) this.neighbors.push(grid[x + 1][y + 1]); // adjusted for rows
            }

            show(color) {
                if (!this.walkable) {
                    ctx.fillStyle = "black";
                    ctx.fillRect(this.x * w, this.y * h, w, h);
                } else {
                    ctx.fillStyle = color;
                    ctx.fillRect(this.x * w, this.y * h, w, h);
                }
            }
        }

        // Heuristic function to calculate the distance between two points
        function heuristic(a, b) {
            const dx = Math.abs(a.x - b.x);
            const dy = Math.abs(a.y - b.y);
            return dx + dy + (Math.sqrt(2) - 2) * Math.min(dx, dy);
        }

        // Draw the current state of the grid
        function drawState() {
            // Draw the current state of the grid
            // fill grid with color
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < cols; j++) {
                    grid[i][j].show("DarkOrange"); // Default color
                }
            }
            for (let point of openSet) {
                point.show("OrangeRed");
            }

            for (let point of closedSet) {
                point.show("Tomato");
            }

            for (let point of path) {
                point.show("SeaGreen");
            }

            start.show("DeepSkyBlue");
            end.show("red");
        }

        // Draw the "No Path Found" text
        function drawNoPath() {
            // Draw a white rectangle as background
            ctx.fillStyle = "white";
            ctx.fillRect(canvasWidth / 3, canvasHeight / 2.2, 202, 36);

            // Display the "No Path Found" text
            ctx.fillStyle = "black";
            ctx.font = "30px Arial";
            ctx.fillText("No Path Found", canvasWidth / 3, canvasHeight / 2);
        }

        // Initialize grid
        function init(mazeData) {
            if (!mazeData || mazeData.length === 0) {
                console.error("mazeData is not initialized");
                return;
            }
            // let rn = Math.floor(Math.random() * 3);


            for (let x = 0; x < cols; x++) {
                grid[x] = new Array(rows);
                for (let y = 0; y < rows; y++) {
                    if (mazeData[y][x] !== undefined) {
                        grid[x][y] = new GridPoint(x, y);
                        grid[x][y].walkable = !!mazeData[y][x];
                    } else {
                        // console.error("Unable to access mazeData[" + y + "][" + x + "]");
                    }
                }
            }

            // define start and end points
            start = grid[1][1];
            end = grid[cols - 2][cols - 2];
            console.log("start: ", start);
            console.log("end: ", end);
            // add start as first element to be evaluated
            openSet.push(start);
        }

        // A* Search
        function search() {
            // Add drawing code to represent the states visually on the canvas
            while (openSet.length > 0) {
                //assumption lowest index is the first one to begin with
                let lowestIndex = 0;
                console.log("openSet: ", openSet.length);
                for (let i = 0; i < openSet.length; i++) {
                    if (openSet[i].f < openSet[lowestIndex].f) {
                        lowestIndex = i;
                    }
                }
                let current = openSet[lowestIndex];
                console.log("current: ", current);
                if (current === end) {
                    let temp = current;
                    path.push(temp);
                    while (temp.parent) {
                        path.reverse().push(temp.parent);
                        temp = temp.parent;
                    }
                    console.log("DONE!");

                    drawState();

                    return;
                }

                //remove current from openSet
                openSet.splice(lowestIndex, 1);

                //add current to closedSet
                closedSet.push(current);

                let neighbors = current.neighbors;
                
                for (let i = 0; i < neighbors.length; i++) {
                    let neighbor = neighbors[i];

                    // skip any obstacles or neighbors that have already been evaluated
                    if (!neighbor.walkable || closedSet.includes(neighbor)) {
                        continue;
                    }

                    const dx = current.x - neighbor.x;
                    const dy = current.y - neighbor.y;
                    const d = dx === 0 || dy === 0 ? 1 : Math.sqrt(
                        2); // 1 if vertical/horizontal neighbor, sqrt(2) if diagonal

                    const tentativeG = current.g + d;

                    if (tentativeG < neighbor.g || !openSet.includes(neighbor)) {
                        neighbor.g = tentativeG;
                        neighbor.h = heuristic(neighbor, end);
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = current;

                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                        }
                    }
                }
                // if no solution
                if (openSet.length === 0) {
                    drawState();
                    drawNoPath();
                }
            }
        }

                // Accessing globally shared data
        window.addEventListener('DOMContentLoaded', (event) => {
            document.getElementById('fetchDataBtn').addEventListener('click', async () => {
                await convertMaze("/mazes/maze.png", 29);  // Wait until data is fetched
                let mazeData = window.sharedData;
                
                console.log("Shared Data: ", window.sharedData);
                console.log("mazeData: ", mazeData);
                if (window.sharedData) {
                    document.getElementById('result').innerHTML = JSON.stringify(window.sharedData);
                }
       
                init(mazeData);
                search();
            });
        });

    </script>
</body>

</html>