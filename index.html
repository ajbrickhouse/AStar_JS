<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script type="text/javascript" src="convertMaze.js" defer></script>
    <title>Canvas Grid</title>
    <style>
        body,
        html {
            height: 100%;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            border: 2px solid black;
        }

        #fetchDataBtn {
            width: 584px;
            /* This will make the button expand to the full width of its container */
        }
    </style>

</head>

<body>
    <div id="canvasContainer" style="width:623px;">
        <!-- Set the width the same as the canvas -->
        <canvas id="gridCanvas" width="623" height="623"></canvas><br>
        <button id="fetchDataBtn">Fetch Data</button>
    </div>
    <div id="result"></div>

    <script>
        window.sharedData = null;

        // Get a reference to the canvas element
        const canvas = document.getElementById("gridCanvas");
        canvas.willReadFrequently = true;
        const ctx = canvas.getContext("2d");

        // Constants
        const cols = 29;
        const rows = 29;

        const cellSize = 20; // Size of each cell in pixels
        const canvasWidth = cols * cellSize;
        const canvasHeight = rows * cellSize;

        // Set canvas dimensions
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        const w = canvasWidth / cols;
        const h = canvasHeight / rows;

        // Initialize grid variables
        let grid = new Array(cols);
        // Store the set of nodes to be evaluated
        let openSet = [];
        // Store the set of nodes already evaluated
        let closedSet = [];
        // obstacles
        let obstacles = [];
        // Starting position
        let start = null;
        // The target position
        let end = null;
        let path = [];
        let draggingEnd = false;

        // GridPoint class definition
        class GridPoint {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.f = 0;
                this.g = 0;
                this.h = 0;
                this.neighbors = [];
                this.parent = undefined;
                this.walkable = null
            }

            updateNeighbors(grid) {
                const x = this.x,
                    y = this.y;
                if (x < cols - 1) this.neighbors.push(grid[x + 1][y]);
                if (x > 0) this.neighbors.push(grid[x - 1][y]);
                if (y < rows - 1) this.neighbors.push(grid[x][y + 1]); // adjusted for rows
                if (y > 0) this.neighbors.push(grid[x][y - 1]);

                // Adding Diagonal Neighbors (also adjusted for rows)
                if (x > 0 && y > 0) this.neighbors.push(grid[x - 1][y - 1]);
                if (x < cols - 1 && y > 0) this.neighbors.push(grid[x + 1][y - 1]);
                if (x > 0 && y < rows - 1) this.neighbors.push(grid[x - 1][y + 1]); // adjusted for rows
                if (x < cols - 1 && y < rows - 1) this.neighbors.push(grid[x + 1][y + 1]); // adjusted for rows
            }

            show(color) {
                if (!this.walkable) {
                    ctx.fillStyle = "black";
                    ctx.fillRect(this.x * w, this.y * h, w, h);
                } else {
                    ctx.fillStyle = color;
                    ctx.fillRect(this.x * w, this.y * h, w, h);
                }
            }
        }

        // Heuristic function to calculate the distance between two points
        function heuristic(a, b) {
            const dx = Math.abs(a.x - b.x);
            const dy = Math.abs(a.y - b.y);
            return dx + dy + (Math.sqrt(2) - 2) * Math.min(dx, dy);
        }

        // Draw the current state of the grid
        function drawState() {
            // Draw the current state of the grid
            // fill grid with color
            console.log("Drawing state");
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < cols; j++) {
                    grid[i][j].show("DarkOrange"); // Default color
                }
            }
            for (let point of openSet) {
                point.show("OrangeRed");
            }

            for (let point of closedSet) {
                point.show("Tomato");
            }

            for (let point of path) {
                point.show("SeaGreen");
            }

            start.show("LimeGreen");
            end.show("red");
        }

        // Draw the "No Path Found" text
        function drawNoPath() {
            // Draw a white rectangle as background
            ctx.fillStyle = "white";
            ctx.fillRect(canvasWidth / 3, canvasHeight / 2.2, 202, 36);

            // Display the "No Path Found" text
            ctx.fillStyle = "black";
            ctx.font = "30px Arial";
            ctx.fillText("No Path Found", canvasWidth / 3, canvasHeight / 2);
        }

        // Initialize grid
        function init(mazeData) {
            if (!mazeData || mazeData.length === 0) {
                console.error("mazeData is not initialized");
                return;
            }
            // let rn = Math.floor(Math.random() * 3);


            for (let x = 0; x < cols; x++) {
                grid[x] = new Array(rows);
                for (let y = 0; y < rows; y++) {
                    if (mazeData[y][x] !== undefined) {
                        grid[x][y] = new GridPoint(x, y);
                        grid[x][y].walkable = !!mazeData[y][x];
                    } else {
                        // console.error("Unable to access mazeData[" + y + "][" + x + "]");
                    }
                }
            }

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < cols; j++) {
                    grid[i][j].updateNeighbors(grid);
                }
            }

        }

        // A* Search
        function search() {
            // print out start and end
            console.log("start: " + start.x + ", " + start.y);
            console.log("end: " + end.x + ", " + end.y);
            console.log("Open Set: " + openSet.length);
            console.log("Closed Set: " + start);
            // Add drawing code to represent the states visually on the canvas
            while (openSet.length > 0) {
                //assumption lowest index is the first one to begin with
                let lowestIndex = 0;
                for (let i = 0; i < openSet.length; i++) {
                    if (openSet[i].f < openSet[lowestIndex].f) {
                        lowestIndex = i;
                    }
                }
                let current = openSet[lowestIndex];
                if (current === end) {
                    let temp = current;
                    path.push(temp);
                    while (temp.parent) {
                        path.reverse().push(temp.parent);
                        temp = temp.parent;
                    }
                    console.log("DONE!");

                    drawState();

                    return;
                }

                //remove current from openSet
                openSet.splice(lowestIndex, 1);

                //add current to closedSet
                closedSet.push(current);

                let neighbors = current.neighbors;

                for (let i = 0; i < neighbors.length; i++) {
                    let neighbor = neighbors[i];

                    // skip any obstacles or neighbors that have already been evaluated
                    if (!neighbor.walkable || closedSet.includes(neighbor)) {
                        continue;
                    }

                    const dx = current.x - neighbor.x;
                    const dy = current.y - neighbor.y;
                    const d = dx === 0 || dy === 0 ? 1 : Math.sqrt(
                    2); // 1 if vertical/horizontal neighbor, sqrt(2) if diagonal

                    const tentativeG = current.g + d;

                    if (tentativeG < neighbor.g || !openSet.includes(neighbor)) {
                        neighbor.g = tentativeG;
                        neighbor.h = heuristic(neighbor, end);
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = current;

                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                        }
                    }
                }
                // if no solution
                if (openSet.length === 0) {
                    drawState();
                    // drawNoPath();
                }
            }
        }

        function clearAll() {
            // clear f, g, h, parent, openSet, closedSet, and path
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < cols; j++) {
                    grid[i][j].f = 0;
                    grid[i][j].g = 0;
                    grid[i][j].h = 0;
                    grid[i][j].parent = undefined;
                }
            }
            openSet = [];
            closedSet = [];
            path = [];
            if (start) {
                openSet.push(start);
            }
        }

        // Accessing globally shared data
        window.addEventListener('DOMContentLoaded', (event) => {
            document.getElementById('fetchDataBtn').addEventListener('click', async () => {
                await convertMaze("/mazes/maze4.png", 29); // Wait until data is fetched
                let mazeData = window.sharedData;
                // define start and end points

                init(mazeData);
                start = grid[0][1];
                // end = grid[cols - 1][cols - 2];
                // check if end is null
                if (!end) {
                    end = grid[cols - 1][cols - 2];
                }
                // add start as first element to be evaluated
                openSet.push(start);
                search();
            });
        });


        // Function to get the grid coordinates from mouse position
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            const x = evt.clientX - rect.left;
            const y = evt.clientY - rect.top;
            return {
                x: Math.floor(x / cellSize),
                y: Math.floor(y / cellSize)
            };
        }

        // Add event listener for mousedown
        canvas.addEventListener("mousedown", function (evt) {
            const pos = getMousePos(canvas, evt);
            // Check if clicked on the end point
            if (pos.x === end.x && pos.y === end.y) {
                draggingEnd = true;
            }
        }, false);

        // Add event listener for mousemove
        canvas.addEventListener("mousemove", function (evt) {
            if (!draggingEnd) return;
            const pos = getMousePos(canvas, evt);
            // Check if the area is walkable before moving the endpoint
            if (grid[pos.x][pos.y].walkable) {
                end.x = pos.x;
                end.y = pos.y;
                console.log("Moving end point to (" + end.x + ", " + end.y + ")");
                clearAll(); // Clear previous state variables
                init(window.sharedData); // Reinitialize grid
                start = grid[0][1]; // Reinitialize start
                end = grid[end.x][end.y]; // Reinitialize end
                openSet.push(start); // Push new start into openSet
                search(); // Restart search
            }
        }, false);

        // Add event listener for mouseup
        canvas.addEventListener("mouseup", function (evt) {
            draggingEnd = false;
        }, false);
    </script>
</body>

</html>