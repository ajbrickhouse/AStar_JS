<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <title>Canvas Grid</title>
    <style>
        body,
        html {
            height: 100%;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            border: 2px solid black;
        }
    </style>

</head>

<body>
    <div id="canvas">
        <canvas id="gridCanvas" width="623" height="623"></canvas><br>
    </div>
    <script id="converMaze">


    </script>
    <script>
        // Get a reference to the canvas element
        const canvas = document.getElementById("gridCanvas");
        const ctx = canvas.getContext("2d");

        // Constants
        const cols = 29;
        const rows = 29;

        const cellSize = 20; // Size of each cell in pixels
        const canvasWidth = cols * cellSize;
        const canvasHeight = rows * cellSize;

        // Set canvas dimensions
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        const w = canvasWidth / cols;
        const h = canvasHeight / rows;

        // Initialize grid variables
        let grid = new Array(cols);
        // Store the set of nodes to be evaluated
        let openSet = [];
        // Store the set of nodes already evaluated
        let closedSet = [];
        // obstacles
        let obstacles = [];
        // Starting position
        let start;
        // The target position
        let end;
        let path = [];
        // let mazeData
        const mazeData  = await processMazeData('/mazes/maze.png', 29).then(result => result.data);

        console.log("post-mazeData", mazeData);

        // GridPoint class definition
        class GridPoint {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.f = 0;
                this.g = 0;
                this.h = 0;
                this.neighbors = [];
                this.parent = undefined;
                this.walkable = null
            }

            updateNeighbors(grid) {
                const x = this.x,
                    y = this.y;
                if (x < cols - 1) this.neighbors.push(grid[x + 1][y]);
                if (x > 0) this.neighbors.push(grid[x - 1][y]);
                if (y < rows - 1) this.neighbors.push(grid[x][y + 1]); // adjusted for rows
                if (y > 0) this.neighbors.push(grid[x][y - 1]);

                // Adding Diagonal Neighbors (also adjusted for rows)
                if (x > 0 && y > 0) this.neighbors.push(grid[x - 1][y - 1]);
                if (x < cols - 1 && y > 0) this.neighbors.push(grid[x + 1][y - 1]);
                if (x > 0 && y < rows - 1) this.neighbors.push(grid[x - 1][y + 1]); // adjusted for rows
                if (x < cols - 1 && y < rows - 1) this.neighbors.push(grid[x + 1][y + 1]); // adjusted for rows
            }

            show(color) {
                if (!this.walkable) {
                    ctx.fillStyle = "black";
                    ctx.fillRect(this.x * w, this.y * h, w, h);
                } else {
                    ctx.fillStyle = color;
                    ctx.fillRect(this.x * w, this.y * h, w, h);
                }
            }
        }

        async function processMazeData(mazeImagePath, mazeSize) {
            try {
                let result = await convertMaze(mazeImagePath, mazeSize);
                let jsListData = result.jsList;
                return jsListData;
            } catch (error) {
                console.error("Error fetching post-mazeData:", error);
            }
        }

        // Heuristic function to calculate the distance between two points
        function heuristic(a, b) {
            const dx = Math.abs(a.x - b.x);
            const dy = Math.abs(a.y - b.y);
            return dx + dy + (Math.sqrt(2) - 2) * Math.min(dx, dy);
        }

        // Draw the current state of the grid
        function drawState() {
            // Draw the current state of the grid
            // fill grid with color
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < cols; j++) {
                    grid[i][j].show("DarkOrange"); // Default color
                }
            }
            for (let point of openSet) {
                point.show("OrangeRed");
            }

            for (let point of closedSet) {
                point.show("Tomato");
            }

            for (let point of path) {
                point.show("SeaGreen");
            }
        }

        // Draw the "No Path Found" text
        function drawNoPath() {
            // Draw a white rectangle as background
            ctx.fillStyle = "white";
            ctx.fillRect(canvasWidth / 3, canvasHeight / 2.2, 202, 36);

            // Display the "No Path Found" text
            ctx.fillStyle = "black";
            ctx.font = "30px Arial";
            ctx.fillText("No Path Found", canvasWidth / 3, canvasHeight / 2);
        }

        // Initialize grid
        function init() {
            if (!mazeData || mazeData.length === 0) {
                console.error("mazeData is not initialized");
                return;
            }
            // let rn = Math.floor(Math.random() * 3);
            let rn = 0;

            if (!mazeData[rn]) {
                console.error("Sub-array mazeData[" + rn + "] is undefined");
                return;
            }

            for (let x = 0; x < cols; x++) {
                grid[x] = new Array(rows);
                for (let y = 0; y < rows; y++) {
                    if (mazeData[rn][y] && mazeData[rn][y][x] !== undefined) {
                        grid[x][y] = new GridPoint(x, y);
                        grid[x][y].walkable = !!mazeData[rn][y][x];
                    } else {
                        // console.error("Unable to access mazeData[" + rn + "][" + y + "][" + x + "]");
                    }
                }
            }

            // define start and end points
            start = grid[0][1];
            end = grid[cols - 1][cols - 2];
            // add start as first element to be evaluated
            openSet.push(start);
        }

        // A* Search
        function search() {
            // Add drawing code to represent the states visually on the canvas
            while (openSet.length > 0) {
                //assumption lowest index is the first one to begin with
                let lowestIndex = 0;
                for (let i = 0; i < openSet.length; i++) {
                    if (openSet[i].f < openSet[lowestIndex].f) {
                        lowestIndex = i;
                    }
                }
                let current = openSet[lowestIndex];

                if (current === end) {
                    let temp = current;
                    path.push(temp);
                    while (temp.parent) {
                        path.reverse().push(temp.parent);
                        temp = temp.parent;
                    }
                    console.log("DONE!");

                    drawState();

                    return;
                }

                //remove current from openSet
                openSet.splice(lowestIndex, 1);

                //add current to closedSet
                closedSet.push(current);

                let neighbors = current.neighbors;

                for (let i = 0; i < neighbors.length; i++) {
                    let neighbor = neighbors[i];

                    // skip any obstacles or neighbors that have already been evaluated
                    if (!neighbor.walkable || closedSet.includes(neighbor)) {
                        continue;
                    }

                    const dx = current.x - neighbor.x;
                    const dy = current.y - neighbor.y;
                    const d = dx === 0 || dy === 0 ? 1 : Math.sqrt(
                        2); // 1 if vertical/horizontal neighbor, sqrt(2) if diagonal

                    const tentativeG = current.g + d;

                    if (tentativeG < neighbor.g || !openSet.includes(neighbor)) {
                        neighbor.g = tentativeG;
                        neighbor.h = heuristic(neighbor, end);
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = current;

                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                        }
                    }
                }
                // if no solution
                if (openSet.length === 0) {
                    drawState();
                    drawNoPath();
                }
            }
        }

        // Call the search function
        init();
        search();
    </script>
</body>

</html>